# Operit 使用“包能力”连接并操控电脑：方案清单

## 结论

可以，且方案很多。基于当前仓库已暴露的能力（包工具、Ubuntu 终端、网络请求、远程 MCP、SSH/SFTP 工作区绑定），可以实现从“发一条命令”到“完整远程运维”的不同层级控制。

> 说明：下面是我能想到的**完整可行清单**（按实操价值排序），你可以按成本和安全要求选。

---

## 现有能力基线（来自本项目）

- `README.md` 已写明：支持 Ubuntu 终端、终端 SSH、SFTP/SSH 工作区绑定、远程 MCP、自动化能力（无障碍/ADB/Root/AutoGLM）。
- `examples/types/system.d.ts` 暴露：`Tools.System.usePackage`、`Tools.System.terminal.create/exec/close`、`Tools.System.shell` 等。
- `docs/package_dev/network.md` 与 `docs/package_dev/okhttp.md` 暴露：`Tools.Net.http*` 与 `OkHttp` 可用于和电脑端服务通信。
- `examples/super_admin.ts` 已提供“终端 + Shell”的可复用包模式。

---

## 方案总览（推荐顺序）

| # | 方案 | 是否可直接控电脑 | 难度 | 推荐度 |
|---|---|---|---|---|
| 1 | SSH 命令执行包（终端里跑 ssh） | 是 | 低 | ⭐⭐⭐⭐⭐ |
| 2 | SSH + SFTP 工作区（文件+命令双通道） | 是 | 低~中 | ⭐⭐⭐⭐⭐ |
| 3 | 电脑端远程 MCP Server | 是 | 中 | ⭐⭐⭐⭐⭐ |
| 4 | 电脑端 HTTP API Agent（FastAPI/Node） | 是 | 中 | ⭐⭐⭐⭐ |
| 5 | WOL（唤醒）+ SSH（执行）组合 | 是 | 中 | ⭐⭐⭐⭐ |
| 6 | 消息队列中转（MQTT/Webhook） | 是 | 中~高 | ⭐⭐⭐ |
| 7 | 远程桌面 App + UI 自动化（曲线控制） | 是（间接） | 高 | ⭐⭐ |
| 8 | ADB/Intent 反向桥接（电脑触发手机） | 间接 | 中 | ⭐⭐ |
| 9 | “只用 Android shell”控制电脑 | 否（仅本机） | 低 | ⭐ |

---

## 各方案详细说明

### 1) SSH 命令执行包（最优先）

**核心思路**
- 在包中调用 `Tools.System.terminal.*`。
- 在 Ubuntu 终端里直接执行 `ssh user@pc "command"`。

**适用场景**
- 重启服务、拉代码、跑脚本、查日志、批处理。

**优势**
- 技术成熟、稳定、实时。
- 权限边界清晰（基于电脑账户权限）。

**注意点**
- 建议只用密钥登录，不要明文密码。
- 要处理交互命令（如 `sudo`）可改成 NOPASSWD 白名单命令。

**包内最小示例（思路）**
```ts
const s = await Tools.System.terminal.create("pc-ops");
const r = await Tools.System.terminal.exec(
  s.sessionId,
  'ssh -i ~/.ssh/id_ed25519 admin@192.168.1.10 "powershell -Command Get-Date"'
);
return { ok: r.exitCode === 0, output: r.output };
```

---

### 2) SSH + SFTP 工作区（文件+命令双通道）

**核心思路**
- 用工作区绑定电脑的 `SFTP/SSH`（仓库 README 已支持）。
- 文件改动走工作区，命令执行走 SSH。

**适用场景**
- 代码同步、配置修改、日志查看、部署。

**优势**
- “编辑 + 执行”链路完整，体验接近远程开发。

**注意点**
- 权限分离：只给目标目录最小权限。

---

### 3) 电脑端远程 MCP Server（结构化控制，长期最佳）

**核心思路**
- 在电脑上运行 MCP Server（暴露工具如 `run_command`、`read_log`、`control_service`）。
- Operit 连接远程 MCP（README 明确支持远程 MCP）。
- AI 以“工具调用”方式触发电脑能力。

**适用场景**
- 多工具编排、可审计自动化、团队共享能力。

**优势**
- 最符合 Operit 生态（MCP/Skill）。
- 参数结构化、可控性和可维护性最好。

**注意点**
- MCP 工具应做严格参数校验和鉴权。

---

### 4) 电脑端 HTTP API Agent（快速落地）

**核心思路**
- 电脑开一个本地服务（如 `http://pc:8787`）。
- 包里用 `Tools.Net.http` / `OkHttp` 发请求，让电脑执行动作。

**适用场景**
- 你已有现成服务框架，想快速联通。

**优势**
- 接入快，调试方便，语言不限。

**注意点**
- 必须加鉴权（Token + IP 白名单 + HTTPS/内网隔离）。
- 服务端要做命令白名单，避免任意命令执行。

---

### 5) WOL（唤醒）+ SSH（执行）组合

**核心思路**
- 包先发送 Wake-on-LAN 魔术包唤醒电脑。
- 电脑上线后自动走 SSH 执行任务。

**适用场景**
- 节能场景：电脑平时休眠，需要时唤醒处理。

**优势**
- 自动化程度高，省电。

**注意点**
- 依赖主板/网卡/路由器配置；跨公网通常需 VPN/内网穿透。

---

### 6) 消息队列中转（MQTT/Webhook）

**核心思路**
- Operit 包发“任务消息”到队列。
- 电脑端守护进程订阅队列并执行，结果再回传。

**适用场景**
- 网络不稳定、需要异步可靠投递、离线重试。

**优势**
- 解耦好，容错高。

**注意点**
- 系统复杂度上升，日志追踪与幂等要设计好。

---

### 7) 远程桌面 App + UI 自动化（曲线控制）

**核心思路**
- 手机安装 RDP/VNC/ToDesk 等远控客户端。
- Operit 用无障碍/AutoGLM 等能力自动点击客户端界面。

**适用场景**
- 必须操作 GUI、且目标软件无 API/CLI。

**优势**
- 理论上“什么都能点”。

**注意点**
- 最脆弱（分辨率/界面变化易失效），维护成本高。
- 建议仅做兜底方案。

---

### 8) ADB/Intent 反向桥接（补充）

**核心思路**
- 电脑通过 ADB/Intent 触发 Operit 工作流，再由包去控电脑端其他服务。

**适用场景**
- 你希望“电脑触发、手机决策执行”的混合架构。

**注意点**
- 这是桥接方案，不是最直接的“手机控电脑”主路径。

---

### 9) 仅 Android shell 的边界说明

`Tools.System.shell` 执行的是 Android 侧命令（通常依赖 Shizuku/Root），
它本身**不是直接控制电脑**，除非再通过网络命令（如 ssh/curl）转到电脑。

---

## 我建议的落地路径（从快到强）

1. **先做 SSH 包 MVP**：先打通“单命令远程执行”。
2. **再做白名单命令层**：把可执行命令固化成工具参数，禁用自由命令。
3. **补充 SFTP 工作区**：形成“改文件 + 执行 + 验证”闭环。
4. **最终升级到远程 MCP**：把能力结构化、可审计化、可复用化。

---

## 安全基线（强烈建议）

- 只控制你授权的电脑，避免任何未授权场景。
- SSH 全部使用密钥认证，禁用密码登录。
- 电脑端仅开放最小端口，尽量走 VPN 内网。
- 包中不要存明文密钥，优先走环境变量或密钥管理。
- 对“执行命令”做白名单，不要暴露任意命令接口。
- 所有远控操作记录审计日志（谁、何时、执行了什么）。

---

## 一句话建议

如果你要“现在就能用”：选 **方案 1（SSH 包）**。  
如果你要“长期稳定可扩展”：做 **方案 3（远程 MCP）**，并保留 SSH 作为兜底通道。

